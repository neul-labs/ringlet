//! Alias-related request handlers.

use crate::server::ServerState;
use ringlet_core::rpc::error_codes;
use ringlet_core::Response;
use std::path::PathBuf;
use tracing::info;

/// Install an alias shim script.
pub async fn install(alias: &str, bin_dir: Option<&PathBuf>, state: &ServerState) -> Response {
    // Verify profile exists
    match state.profile_manager.get(alias) {
        Ok(Some(_)) => {}
        Ok(None) => {
            return Response::error(
                error_codes::PROFILE_NOT_FOUND,
                format!("Profile not found: {}", alias),
            );
        }
        Err(e) => {
            return Response::error(
                error_codes::INTERNAL_ERROR,
                format!("Failed to read profile: {}", e),
            );
        }
    }

    // Determine target directory
    let target_dir = bin_dir
        .cloned()
        .or_else(|| default_bin_dir())
        .unwrap_or_else(|| PathBuf::from("."));

    // Ensure target directory exists
    if let Err(e) = std::fs::create_dir_all(&target_dir) {
        return Response::error(
            error_codes::INTERNAL_ERROR,
            format!("Failed to create bin directory: {}", e),
        );
    }

    // Generate and write the shim script
    let shim_path = target_dir.join(alias);
    let shim_content = generate_shim_script(alias);

    if let Err(e) = std::fs::write(&shim_path, &shim_content) {
        return Response::error(
            error_codes::INTERNAL_ERROR,
            format!("Failed to write shim script: {}", e),
        );
    }

    // Make executable on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Err(e) = std::fs::set_permissions(&shim_path, std::fs::Permissions::from_mode(0o755)) {
            return Response::error(
                error_codes::INTERNAL_ERROR,
                format!("Failed to set permissions: {}", e),
            );
        }
    }

    info!("Installed alias shim: {:?}", shim_path);
    Response::success(format!(
        "Alias '{}' installed at {}",
        alias,
        shim_path.display()
    ))
}

/// Uninstall an alias shim script.
pub async fn uninstall(alias: &str, state: &ServerState) -> Response {
    // Try common locations
    let locations = vec![
        default_bin_dir(),
        Some(PathBuf::from("/usr/local/bin")),
    ];

    let mut found = false;
    for loc in locations.into_iter().flatten() {
        let shim_path = loc.join(alias);
        if shim_path.exists() {
            match std::fs::remove_file(&shim_path) {
                Ok(()) => {
                    info!("Removed alias shim: {:?}", shim_path);
                    found = true;
                }
                Err(e) => {
                    return Response::error(
                        error_codes::INTERNAL_ERROR,
                        format!("Failed to remove shim: {}", e),
                    );
                }
            }
        }
    }

    if found {
        Response::success(format!("Alias '{}' uninstalled", alias))
    } else {
        Response::error(
            error_codes::PROFILE_NOT_FOUND,
            format!("Alias shim not found for: {}", alias),
        )
    }
}

/// Generate a shell shim script for an alias.
fn generate_shim_script(alias: &str) -> String {
    #[cfg(unix)]
    {
        format!(
            r#"#!/bin/sh
# Auto-generated by ringlet for profile: {}
# This script invokes the agent with the configured profile

exec ringlet profiles run {} -- "$@"
"#,
            alias, alias
        )
    }

    #[cfg(windows)]
    {
        format!(
            r#"@echo off
REM Auto-generated by ringlet for profile: {}
REM This script invokes the agent with the configured profile

ringlet profiles run {} -- %*
"#,
            alias, alias
        )
    }
}

/// Get the default bin directory for shim scripts.
fn default_bin_dir() -> Option<PathBuf> {
    // Try ~/.local/bin first (XDG standard)
    if let Some(home) = ringlet_core::home_dir() {
        let local_bin = home.join(".local/bin");
        if local_bin.exists() || std::fs::create_dir_all(&local_bin).is_ok() {
            return Some(local_bin);
        }

        // Fallback to ~/bin
        let home_bin = home.join("bin");
        if home_bin.exists() || std::fs::create_dir_all(&home_bin).is_ok() {
            return Some(home_bin);
        }
    }
    None
}
